{
  "version": 3,
  "sources": ["../../../cloudflare-worker.js"],
  "sourceRoot": "/Users/okoro/dev/patreek-web/.wrangler/tmp/deploy-Asvk6o",
  "sourcesContent": ["/**\n * Cloudflare Worker: Reverse Proxy for patreek.com with Rate Limiting\n *\n * Architecture:\n * - patreek.com is connected to Cloudflare Pages (patreek-web.pages.dev)\n * - Worker runs on patreek.com/* to selectively route requests\n *\n * Routing logic:\n * - / \u2192 Fetch from Cloudflare Pages (patreek-web.pages.dev) - homepage with feed list\n * - /pat/* \u2192 Fetch from Cloudflare Pages (patreek-web.pages.dev) - article pages\n * - /registration \u2192 Fetch from Cloudflare Pages (patreek-web.pages.dev) - registration page\n * - /contact \u2192 Fetch from Cloudflare Pages (patreek-web.pages.dev) - contact page\n * - /ads.txt \u2192 Fetch from Cloudflare Pages (patreek-web.pages.dev)\n * - /_next/* (Next.js assets) \u2192 Fetch from Cloudflare Pages\n * - /static/* (static assets) \u2192 Fetch from Cloudflare Pages\n * - *.txt (Next.js RSC payload files) \u2192 Fetch from Cloudflare Pages\n * - Requests with ?_rsc query parameter \u2192 Fetch from Cloudflare Pages\n * - /favicon.ico, /robots.txt, /sitemap.xml \u2192 Fetch from Cloudflare Pages\n * - Everything else \u2192 Proxy to patreek.webflow.io\n *\n * Rate Limiting:\n * - Uses KV storage (optional) or in-memory cache\n * - Tracks requests per IP address\n * - Configurable limits per time window\n * - Returns 429 Too Many Requests when limit exceeded\n *\n * Setup Steps:\n * 1. Connect patreek.com to Cloudflare Pages (custom domain)\n * 2. Configure Worker route: patreek.com/*\n * 3. (Optional) Create KV namespace and bind it to the Worker\n * 4. Update PAGES_DEPLOYMENT_URL below with your actual Pages URL\n */\n\n// \u26A0\uFE0F UPDATE THIS: Your Cloudflare Pages deployment URL\nconst PAGES_DEPLOYMENT_URL = 'https://patreek-web.pages.dev'\n\n// Rate limiting configuration\nconst RATE_LIMIT_CONFIG = {\n  // Maximum requests per IP per time window\n  MAX_REQUESTS_PER_WINDOW: 100, // Adjust based on your needs\n  // Time window in seconds (e.g., 60 = 1 minute)\n  TIME_WINDOW_SECONDS: 60,\n  // Paths to rate limit (empty array = rate limit all paths)\n  // Rate limit /pat/* routes to protect against DDoS\n  RATE_LIMIT_PATHS: ['/pat/'],\n  // Use KV storage for persistence (set to false to use in-memory only - FREE TIER)\n  // Set to true only if you've configured KV namespace (requires paid plan for high usage)\n  USE_KV: false // FREE TIER: Set to false for in-memory rate limiting (no cost)\n}\n\n// In-memory rate limit store (fallback if KV not available)\n// Note: This resets on worker restart, but is fine for basic protection\nconst inMemoryRateLimit = new Map()\n\n/**\n * Get client IP address from request headers\n */\nfunction getClientIP(request) {\n  // Cloudflare provides the real IP in CF-Connecting-IP header\n  const cfConnectingIP = request.headers.get('CF-Connecting-IP')\n  if (cfConnectingIP) {\n    return cfConnectingIP\n  }\n\n  // Fallback to X-Forwarded-For if available\n  const xForwardedFor = request.headers.get('X-Forwarded-For')\n  if (xForwardedFor) {\n    return xForwardedFor.split(',')[0].trim()\n  }\n\n  // Last resort: use a default identifier\n  return 'unknown'\n}\n\n/**\n * Check if path should be rate limited\n */\nfunction shouldRateLimit(pathname) {\n  if (RATE_LIMIT_CONFIG.RATE_LIMIT_PATHS.length === 0) {\n    return true // Rate limit all paths\n  }\n\n  return RATE_LIMIT_CONFIG.RATE_LIMIT_PATHS.some((path) =>\n    pathname.startsWith(path)\n  )\n}\n\n/**\n * Get rate limit key for KV storage\n */\nfunction getRateLimitKey(ip, pathname) {\n  const window = Math.floor(\n    Date.now() / (RATE_LIMIT_CONFIG.TIME_WINDOW_SECONDS * 1000)\n  )\n  return `ratelimit:${ip}:${pathname}:${window}`\n}\n\n/**\n * Check rate limit using KV storage\n */\nasync function checkRateLimitKV(env, ip, pathname) {\n  if (!env.RATE_LIMIT_KV) {\n    return {\n      allowed: true,\n      remaining: RATE_LIMIT_CONFIG.MAX_REQUESTS_PER_WINDOW\n    }\n  }\n\n  const key = getRateLimitKey(ip, pathname)\n\n  try {\n    const count = await env.RATE_LIMIT_KV.get(key)\n    const currentCount = count ? parseInt(count, 10) : 0\n\n    if (currentCount >= RATE_LIMIT_CONFIG.MAX_REQUESTS_PER_WINDOW) {\n      return {\n        allowed: false,\n        remaining: 0,\n        resetIn:\n          RATE_LIMIT_CONFIG.TIME_WINDOW_SECONDS -\n          (Date.now() % (RATE_LIMIT_CONFIG.TIME_WINDOW_SECONDS * 1000)) / 1000\n      }\n    }\n\n    // Increment counter\n    const newCount = currentCount + 1\n    await env.RATE_LIMIT_KV.put(key, newCount.toString(), {\n      expirationTtl: RATE_LIMIT_CONFIG.TIME_WINDOW_SECONDS + 10 // Add buffer\n    })\n\n    return {\n      allowed: true,\n      remaining: RATE_LIMIT_CONFIG.MAX_REQUESTS_PER_WINDOW - newCount\n    }\n  } catch (error) {\n    console.error('[Rate Limit] KV error:', error)\n    // On error, allow the request (fail open)\n    return {\n      allowed: true,\n      remaining: RATE_LIMIT_CONFIG.MAX_REQUESTS_PER_WINDOW\n    }\n  }\n}\n\n/**\n * Check rate limit using in-memory storage\n */\nfunction checkRateLimitInMemory(ip, pathname) {\n  const key = getRateLimitKey(ip, pathname)\n  const now = Date.now()\n\n  // Clean up old entries (older than 2 time windows)\n  const cleanupThreshold = now - RATE_LIMIT_CONFIG.TIME_WINDOW_SECONDS * 2000\n  for (const [k, v] of inMemoryRateLimit.entries()) {\n    if (v.timestamp < cleanupThreshold) {\n      inMemoryRateLimit.delete(k)\n    }\n  }\n\n  const entry = inMemoryRateLimit.get(key)\n\n  if (entry && entry.count >= RATE_LIMIT_CONFIG.MAX_REQUESTS_PER_WINDOW) {\n    const resetIn =\n      RATE_LIMIT_CONFIG.TIME_WINDOW_SECONDS -\n      (((now - entry.timestamp) / 1000) % RATE_LIMIT_CONFIG.TIME_WINDOW_SECONDS)\n\n    return {\n      allowed: false,\n      remaining: 0,\n      resetIn: Math.ceil(resetIn)\n    }\n  }\n\n  // Increment or create entry\n  if (entry) {\n    entry.count++\n  } else {\n    inMemoryRateLimit.set(key, {\n      count: 1,\n      timestamp: now\n    })\n  }\n\n  const currentCount = inMemoryRateLimit.get(key).count\n\n  return {\n    allowed: true,\n    remaining: RATE_LIMIT_CONFIG.MAX_REQUESTS_PER_WINDOW - currentCount\n  }\n}\n\n/**\n * Check rate limit (uses KV if available, otherwise in-memory)\n */\nasync function checkRateLimit(env, ip, pathname) {\n  if (RATE_LIMIT_CONFIG.USE_KV && env.RATE_LIMIT_KV) {\n    return await checkRateLimitKV(env, ip, pathname)\n  } else {\n    return checkRateLimitInMemory(ip, pathname)\n  }\n}\n\nexport default {\n  async fetch(request, env) {\n    const url = new URL(request.url)\n    const pathname = url.pathname\n    const hostname = url.hostname\n\n    // Debug logging (remove in production)\n    console.log(`[Worker] Request: ${hostname}${pathname}`)\n\n    // Redirect www to non-www for SEO and consistency\n    // This ensures www.patreek.com/ads.txt redirects to patreek.com/ads.txt\n    if (hostname === 'www.patreek.com') {\n      return Response.redirect(\n        `https://patreek.com${pathname}${url.search}`,\n        301\n      )\n    }\n\n    // Rate limiting check\n    let rateLimitHeaders = null\n    if (shouldRateLimit(pathname)) {\n      const clientIP = getClientIP(request)\n      const rateLimitResult = await checkRateLimit(env, clientIP, pathname)\n\n      if (!rateLimitResult.allowed) {\n        console.warn(\n          `[Rate Limit] Blocked request from ${clientIP} for ${pathname}`\n        )\n\n        return new Response(\n          JSON.stringify({\n            error: 'Too Many Requests',\n            message: 'Rate limit exceeded. Please try again later.',\n            retryAfter:\n              rateLimitResult.resetIn || RATE_LIMIT_CONFIG.TIME_WINDOW_SECONDS\n          }),\n          {\n            status: 429,\n            statusText: 'Too Many Requests',\n            headers: {\n              'Content-Type': 'application/json',\n              'Retry-After': String(\n                rateLimitResult.resetIn || RATE_LIMIT_CONFIG.TIME_WINDOW_SECONDS\n              ),\n              'X-RateLimit-Limit': String(\n                RATE_LIMIT_CONFIG.MAX_REQUESTS_PER_WINDOW\n              ),\n              'X-RateLimit-Remaining': String(rateLimitResult.remaining || 0),\n              'X-RateLimit-Reset': String(\n                Date.now() +\n                  (rateLimitResult.resetIn ||\n                    RATE_LIMIT_CONFIG.TIME_WINDOW_SECONDS) *\n                    1000\n              )\n            }\n          }\n        )\n      }\n\n      // Store rate limit headers to add to successful responses\n      rateLimitHeaders = {\n        'X-RateLimit-Limit': String(RATE_LIMIT_CONFIG.MAX_REQUESTS_PER_WINDOW),\n        'X-RateLimit-Remaining': String(rateLimitResult.remaining),\n        'X-RateLimit-Reset': String(\n          Date.now() + RATE_LIMIT_CONFIG.TIME_WINDOW_SECONDS * 1000\n        )\n      }\n    }\n\n    // Handle /pat routes (main public routes)\n    // Next.js static export generates /pat.html for the catch-all route [[...id]]\n    // This single HTML file handles both /pat/ (homepage) and /pat/{id} (article) routes\n\n    // Handle RSC payload requests for /pat/{id}.txt\n    // Next.js requests these for client-side navigation, but static export only generates /pat.txt\n    if (pathname.match(/^\\/pat\\/(\\d+)\\.txt$/)) {\n      const rscPath = '/pat.txt'\n      console.log(`[Worker] Routing RSC payload ${pathname} to ${rscPath}`)\n      const pagesUrl = `${PAGES_DEPLOYMENT_URL}${rscPath}${url.search}`\n\n      try {\n        const response = await fetch(pagesUrl, {\n          method: request.method,\n          headers: request.headers,\n          body: request.body\n        })\n\n        if (response.status === 200) {\n          const newHeaders = new Headers(response.headers)\n          newHeaders.set('Content-Type', 'text/plain; charset=utf-8')\n          newHeaders.set('Access-Control-Allow-Origin', '*')\n\n          // Add rate limit headers if available\n          if (rateLimitHeaders) {\n            Object.entries(rateLimitHeaders).forEach(([key, value]) => {\n              newHeaders.set(key, value)\n            })\n          }\n\n          return new Response(response.body, {\n            status: response.status,\n            statusText: response.statusText,\n            headers: newHeaders\n          })\n        } else {\n          // If /pat.txt doesn't exist, return empty RSC payload to suppress errors\n          console.warn(\n            `[Worker] RSC payload ${rscPath} not found, returning empty payload`\n          )\n          return new Response('', {\n            status: 200,\n            headers: {\n              'Content-Type': 'text/plain; charset=utf-8',\n              'Access-Control-Allow-Origin': '*'\n            }\n          })\n        }\n      } catch (error) {\n        console.error('[Worker] Error fetching RSC payload:', error)\n        // Return empty payload to suppress errors\n        return new Response('', {\n          status: 200,\n          headers: {\n            'Content-Type': 'text/plain; charset=utf-8',\n            'Access-Control-Allow-Origin': '*'\n          }\n        })\n      }\n    }\n\n    // Redirect /pat (no trailing slash) to /pat/ (with trailing slash)\n    if (pathname === '/pat') {\n      return Response.redirect(`${url.origin}/pat/`, 301)\n    }\n\n    // For /pat/ (homepage) and /pat/{id} (article pages), route to /pat.html\n    // The React app will extract the ID from the URL and fetch data from the API if needed\n    if (pathname === '/pat/' || pathname.match(/^\\/pat\\/(\\d+)$/)) {\n      const htmlPath = '/pat.html'\n      console.log(`[Worker] Routing ${pathname} to ${htmlPath}`)\n      const pagesUrl = `${PAGES_DEPLOYMENT_URL}${htmlPath}${url.search}`\n\n      try {\n        const response = await fetch(pagesUrl, {\n          method: request.method,\n          headers: request.headers,\n          body: request.body\n        })\n\n        if (response.status === 200) {\n          const newHeaders = new Headers(response.headers)\n          newHeaders.set('Content-Type', 'text/html; charset=utf-8')\n          newHeaders.set('Access-Control-Allow-Origin', '*')\n\n          // Add rate limit headers if available\n          if (rateLimitHeaders) {\n            Object.entries(rateLimitHeaders).forEach(([key, value]) => {\n              newHeaders.set(key, value)\n            })\n          }\n\n          console.log(\n            `[Worker] Successfully fetched ${htmlPath} for route ${pathname}`\n          )\n          return new Response(response.body, {\n            status: response.status,\n            statusText: response.statusText,\n            headers: newHeaders\n          })\n        } else {\n          console.error(\n            `[Worker] Failed to fetch ${htmlPath}: ${response.status}`\n          )\n          return new Response(`Page not found (${response.status})`, {\n            status: response.status\n          })\n        }\n      } catch (error) {\n        console.error('[Worker] Error fetching HTML:', error)\n        return new Response('Error fetching page from Pages', { status: 500 })\n      }\n    }\n\n    // Handle root path (/) - route to index.html (which shows feed list)\n    if (pathname === '/') {\n      const htmlPath = '/index.html'\n      console.log(`[Worker] Routing root path to ${htmlPath}`)\n      const pagesUrl = `${PAGES_DEPLOYMENT_URL}${htmlPath}${url.search}`\n\n      try {\n        const response = await fetch(pagesUrl, {\n          method: request.method,\n          headers: request.headers,\n          body: request.body\n        })\n\n        if (response.status === 200) {\n          const newHeaders = new Headers(response.headers)\n          newHeaders.set('Content-Type', 'text/html; charset=utf-8')\n          newHeaders.set('Access-Control-Allow-Origin', '*')\n\n          // Add rate limit headers if available\n          if (rateLimitHeaders) {\n            Object.entries(rateLimitHeaders).forEach(([key, value]) => {\n              newHeaders.set(key, value)\n            })\n          }\n\n          console.log(`[Worker] Successfully fetched ${htmlPath} for root path`)\n          return new Response(response.body, {\n            status: response.status,\n            statusText: response.statusText,\n            headers: newHeaders\n          })\n        } else {\n          console.error(\n            `[Worker] Failed to fetch ${htmlPath}: ${response.status}`\n          )\n          return new Response(`Page not found (${response.status})`, {\n            status: response.status\n          })\n        }\n      } catch (error) {\n        console.error('[Worker] Error fetching HTML:', error)\n        return new Response('Error fetching page from Pages', { status: 500 })\n      }\n    }\n\n    // Handle /registration route - route to registration.html\n    if (pathname === '/registration' || pathname === '/registration/') {\n      const htmlPath = '/registration.html'\n      console.log(`[Worker] Routing ${pathname} to ${htmlPath}`)\n      const pagesUrl = `${PAGES_DEPLOYMENT_URL}${htmlPath}${url.search}`\n\n      try {\n        const response = await fetch(pagesUrl, {\n          method: request.method,\n          headers: request.headers,\n          body: request.body\n        })\n\n        if (response.status === 200) {\n          const newHeaders = new Headers(response.headers)\n          newHeaders.set('Content-Type', 'text/html; charset=utf-8')\n          newHeaders.set('Access-Control-Allow-Origin', '*')\n\n          // Add rate limit headers if available\n          if (rateLimitHeaders) {\n            Object.entries(rateLimitHeaders).forEach(([key, value]) => {\n              newHeaders.set(key, value)\n            })\n          }\n\n          console.log(`[Worker] Successfully fetched ${htmlPath} for registration`)\n          return new Response(response.body, {\n            status: response.status,\n            statusText: response.statusText,\n            headers: newHeaders\n          })\n        } else {\n          console.error(\n            `[Worker] Failed to fetch ${htmlPath}: ${response.status}`\n          )\n          return new Response(`Page not found (${response.status})`, {\n            status: response.status\n          })\n        }\n      } catch (error) {\n        console.error('[Worker] Error fetching registration page:', error)\n        return new Response('Error fetching page from Pages', { status: 500 })\n      }\n    }\n\n    // Handle /contact route - route to contact.html\n    if (pathname === '/contact' || pathname === '/contact/') {\n      const htmlPath = '/contact.html'\n      console.log(`[Worker] Routing ${pathname} to ${htmlPath}`)\n      const pagesUrl = `${PAGES_DEPLOYMENT_URL}${htmlPath}${url.search}`\n\n      try {\n        const response = await fetch(pagesUrl, {\n          method: request.method,\n          headers: request.headers,\n          body: request.body\n        })\n\n        if (response.status === 200) {\n          const newHeaders = new Headers(response.headers)\n          newHeaders.set('Content-Type', 'text/html; charset=utf-8')\n          newHeaders.set('Access-Control-Allow-Origin', '*')\n\n          // Add rate limit headers if available\n          if (rateLimitHeaders) {\n            Object.entries(rateLimitHeaders).forEach(([key, value]) => {\n              newHeaders.set(key, value)\n            })\n          }\n\n          console.log(`[Worker] Successfully fetched ${htmlPath} for contact`)\n          return new Response(response.body, {\n            status: response.status,\n            statusText: response.statusText,\n            headers: newHeaders\n          })\n        } else {\n          console.error(\n            `[Worker] Failed to fetch ${htmlPath}: ${response.status}`\n          )\n          return new Response(`Page not found (${response.status})`, {\n            status: response.status\n          })\n        }\n      } catch (error) {\n        console.error('[Worker] Error fetching contact page:', error)\n        return new Response('Error fetching page from Pages', { status: 500 })\n      }\n    }\n\n    // Route /ads.txt, Next.js assets, and RSC payload files to Cloudflare Pages\n    // Note: /public/pats/* routes are handled above\n    if (\n      pathname === '/ads.txt' ||\n      pathname.startsWith('/_next/') ||\n      pathname.startsWith('/static/') ||\n      pathname.startsWith('/favicon.ico') ||\n      pathname.startsWith('/robots.txt') ||\n      pathname.startsWith('/sitemap.xml') ||\n      pathname.endsWith('.txt') || // Next.js RSC payload files (index.txt, privacy.txt, terms.txt, etc.)\n      url.searchParams.has('_rsc') // Next.js RSC requests with _rsc query parameter\n    ) {\n      console.log(`[Worker] Routing to Pages: ${pathname}`)\n      const pagesUrl = `${PAGES_DEPLOYMENT_URL}${pathname}${url.search}`\n\n      try {\n        const response = await fetch(pagesUrl, {\n          method: request.method,\n          headers: request.headers,\n          body: request.body\n        })\n\n        // Clone response and ensure proper headers\n        const newHeaders = new Headers(response.headers)\n\n        // Ensure proper Content-Type for CSS and JS files\n        if (pathname.endsWith('.css')) {\n          newHeaders.set('Content-Type', 'text/css; charset=utf-8')\n        } else if (pathname.endsWith('.js')) {\n          newHeaders.set(\n            'Content-Type',\n            'application/javascript; charset=utf-8'\n          )\n        }\n\n        // Ensure CORS headers for cross-origin requests\n        newHeaders.set('Access-Control-Allow-Origin', '*')\n        newHeaders.set('Access-Control-Allow-Methods', 'GET, HEAD, OPTIONS')\n\n        // Add rate limit headers if available\n        if (request.rateLimitHeaders) {\n          Object.entries(request.rateLimitHeaders).forEach(([key, value]) => {\n            newHeaders.set(key, value)\n          })\n        }\n\n        const newResponse = new Response(response.body, {\n          status: response.status,\n          statusText: response.statusText,\n          headers: newHeaders\n        })\n\n        return newResponse\n      } catch (error) {\n        console.error('[Worker] Error fetching from Pages:', error)\n        return new Response('Error fetching content from Pages', {\n          status: 500\n        })\n      }\n    }\n\n    // Proxy all other requests to patreek.webflow.io\n    console.log(`[Worker] Routing to Webflow: ${pathname}`)\n    const targetUrl = `https://patreek.webflow.io${pathname}${url.search}`\n\n    const modifiedRequest = new Request(targetUrl, {\n      method: request.method,\n      headers: request.headers,\n      body: request.body\n    })\n\n    const response = await fetch(modifiedRequest)\n\n    const modifiedResponse = new Response(response.body, {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers\n    })\n\n    modifiedResponse.headers.set('X-Content-Type-Options', 'nosniff')\n    modifiedResponse.headers.set('X-Frame-Options', 'SAMEORIGIN')\n\n    // Add rate limit headers if available\n    if (rateLimitHeaders) {\n      Object.entries(rateLimitHeaders).forEach(([key, value]) => {\n        modifiedResponse.headers.set(key, value)\n      })\n    }\n\n    return modifiedResponse\n  }\n}\n"],
  "mappings": "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",
  "names": ["response"]
}
